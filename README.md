<!--
 * @Description:  readme
 * @Author: chengjun_xu
 * @Data: Do not edit
 * @LastAuthor: Do not edit
 * @LastEditTime: 2022-01-04 10:56:56
-->
# DesignPattern

## 设计模式8大原则：

1. 依赖倒置原则：高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖于抽象（稳定）。抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖抽象（稳定）。

2. 开放封闭原则：对扩展开放，对更改封闭。类模块是可扩展的，但不可修改。

3. 单一职责原则：一个类应该仅有一个引起它变化的原因，变化方向隐含类的责任。

4. Liskov替换原则：子类必须能替换它们的基类，继承表达类型抽象。

5. 接口隔离原则：不应该强迫客户程序依赖它们不用的方法；接口小而完备。

6. 优先使用对象组合，而不是类继承。

7. 封装变化点：松耦合。

8. 针对接口编程，而不是针对实现编程。


## 重构关键技术：

1. 静态 -> 动态

2. 早绑定 -> 晚绑定

3. 继承 -> 组合

4. 编译时依赖 ->  运行时依赖

5. 紧耦合 -> 松耦合


## 模式分类：

1. 组件协作：模板模式，策略模式，观察者/事件模式

2. 单一职责：装饰者模式，桥模式

3. 对象创建：工厂模式，抽象工厂模式，建造者模式，原型模式

4. 对象性能：单一模式，享元模式

5. 接口隔离：外观模式， 代理模式，中介模式，适配器模式

6. 状态变化：备忘录模式，状态模式

7. 数据结构：组合模式，迭代器模式，职责链模式，职责模式

8. 行为变化：命令模式，访问者模式

9. 领域问题：解释器模式


## 适用场景：

#### 1. 工厂模式

定义：

    定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是的一个类的实例化延迟(目的：解耦，手段：虚函数)到子类

动机：

    在面向对象时，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化

解决方案：

    绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“具体对象创建”的紧耦合（依赖具体类）

图示：
    

总结：

    1.工厂模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合（new）关系会导致软件的脆弱
    2.工厂模式通过面向对象的手法，将所需要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种耦合关系
    3.工厂模式解决“单个对象”的需求变化。缺点在于创建方法/参数相同


#### 2. 抽象工厂模式

定义：

    提供一个接口，让该接口负责创建一系列“相关股则相互依赖的对象”，无需指定它们具体的类

动机：

    在面向对象时，经常面临“一系列相互依赖的对象”的创建工作；由于需求的变化，往往存在更多的系列对象的创建工作

总结：

    1. 如果没有应对“多系列对象创建”的需求变化，则没有必要使用抽象工厂模式，这时候可以使用简单工厂就行
    2. “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用关系。不同系列的对象之间不能相互依赖
    3. 抽象工厂模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动


#### 3. 建造者模式

定义：

    将一个复杂对象的构建与其表示相分离，使用同样的构建过程（稳定）可以创建不同的表示（变化）

动机：

    1. 有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临剧烈的变化，但是将它们组合在一起的算法却相对稳定；
    2. 保持系统中的“稳定构建算法”不随着需求改变而改变；

总结：

    1. 主要用于“分步构建一个复杂的对象”。其中，”分步“是一个稳定算法，而复杂对象的各个部分则经常变化
    2. 应对”复杂对象各个部分“的频繁需求变动。缺点在于难以应对”分步构建算法“的需求变动
    3. 注意不同语言构造器中调用虚函数的差别（C++ vs C#、Java）


#### 4. 原型模式

定义：

    使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象

动机：

    1. 在软件系统中，经常面临“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临剧烈的变化，但是它们却拥有比较稳定一致接口；
    2. 如何向“客户程序”隔离出“这些易变对象”，从而使“依赖这些易变对象的客户程序”不随着需求改变而改变；

总结：

    1. 原型模式同样适用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有稳定的接口；
    2. 原型模式对于“如何创建易变类的实例对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活的动态创建“拥有某些稳定接口”的新对象----所需工作仅仅是注册一个新类的对象（原型），然后在任何有需要的地方Clone;
    3. 原型模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝；